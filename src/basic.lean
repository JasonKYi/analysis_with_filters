import order.filter.basic topology.separation tactic

variables {α : Type*}

noncomputable theory

open set classical
local attribute [instance] classical.prop_decidable

/-
structure filter (α : Type*) :=
(sets                   : set (set α))
(univ_sets              : set.univ ∈ sets)
(sets_of_superset {x y} : x ∈ sets → x ⊆ y → y ∈ sets)
(inter_sets {x y}       : x ∈ sets → y ∈ sets → x ∩ y ∈ sets)

-- A filter on `α` is a set of sets of `α` containing `α` itself, closed under 
-- supersets and intersection.

-- NB. This definition of filters does not require `∅ ∉ sets`. This is done so 
-- we can create a lattice structure. `∅ ∉ sets` should be included as a 
-- seperate proposition in lemmas.
-/

-- I'm going to follow 
-- https://web.archive.org/web/20071009170540/http://www.efnet-math.org/~david/mathematics/filters.pdf

-- First, we will find a way to generate filters for any given set of sets of α
-- To achieve this, we consider that the intersection of a collection of filters 
-- is also a filter, so therefore, a filter can be generated form a set of sets 
-- by taking the intersection of all filters containing this set, i.e. if `S` is 
-- type `set (set α)`, then the filter generated by `S` is 
-- ⋂₀ { F : filter α | S ⊆ F.sets }

namespace filter

instance : has_coe (filter α) (set (set α)) := ⟨λ F, F.sets⟩

/- /-- The intersection of two filters is a filter-/
instance : has_inter (filter α) := ⟨λ F G, 
  { sets := (F : set (set α)) ∩ (G : set (set α)),
    univ_sets := ⟨F.univ_sets, G.univ_sets⟩,
    sets_of_superset := λ _ _ ⟨hxF, hxG⟩ hsub,
      ⟨F.sets_of_superset hxF hsub, G.sets_of_superset hxG hsub⟩,
    inter_sets := λ x y ⟨hxF, hxG⟩ ⟨hyF, hyG⟩,
      ⟨F.inter_sets hxF hyF, G.inter_sets hxG hyG⟩ }⟩ -/

/-- The intersection of a collection of filters is a filter -/
instance : has_Inf (filter α) := { Inf := λ 𝒞,
  { sets := ⋂ (F ∈ 𝒞), (F : set (set α)), 
    univ_sets := mem_bInter $ λ F hF, F.univ_sets,
    sets_of_superset := λ _ _ hx hsub, mem_bInter $ λ F hF, 
      F.sets_of_superset (mem_bInter_iff.1 hx F hF) hsub,
    inter_sets := λ x y hx hy, mem_bInter $ λ F hF, 
      F.inter_sets (mem_bInter_iff.1 hx F hF) (mem_bInter_iff.1 hy F hF) }}

-- With that we can now define the filter generated by an arbitary set of sets 

/-- The filter generated from `S`, a set of sets of `α` is the Inf of all filters 
  containing `S` -/
def generated_from (S : set (set α)) : filter α := 
  Inf { F : filter α | S ⊆ F.sets }

variables {S : set (set α)}

lemma le_generated_from : S ⊆ generated_from S := 
  λ s hs, mem_bInter (λ F hF, hF hs)

-- Straightaway, we see that if `∅ ∈ S`, then `filter_generated_from S` is the 
-- powerset of `α` 

lemma generated_of_empty (hS : ∅ ∈ S) (s : set α) : s ∈ generated_from S :=
  (generated_from S).sets_of_superset (le_generated_from hS) (empty_subset s)

/-- Let `F` be a `ne_bot` filter on `α`, `F` is an ultra filter if for all 
  `S : set α`, `S ∈ F` or `Sᶜ ∈ F` -/
@[class] structure ultra (F : filter α) :=
(ne_bot : ne_bot F)
(mem_or_compl_mem {S : set α} : S ∈ F ∨ Sᶜ ∈ F)

-- The ultra filter theorem states that for all `F : filter α`, there exists 
-- some ultra filter `𝕌`, `F ⊆ 𝕌`.

-- The proof of this follows from Zorn's lemma.
-- Let `F` be a filter on `α`, We have the filters of `α` that contain `F` form 
-- a poset. Let `𝒞` be a chain (a totaly ordered set) within this set, then by 
-- Zorn's lemma, `𝒞` has at least one maximum element. Thus, by checking this 
-- maximum element is indeed an ultra filter, we have found a ultra filter 
-- containing `F`.

-- #check exists_maximal_of_chains_bounded

-- theorem exists_ultra_ge (F : filter α) [ne_bot F] : 
--   ∃ (G : filter α) [H : ultra G], F ≤ G := sorry

-- Let X be a Hausdorff space
variables {X : Type*} [topological_space X]

/-- A filter `F` on a Hausdorff space `X` has at most one limit -/
theorem tendsto_unique {x y : X} {F : filter X} [H : ne_bot F] [t2_space X]
  (hFx : tendsto id F (nhds x)) 
  (hFy : tendsto id F (nhds y)) : x = y :=
begin
  by_contra hneq,
  rcases t2_space.t2 _ _ hneq with ⟨U, V, hU, hV, hxU, hyV, hdisj⟩,
  apply H, rw [←empty_in_sets_eq_bot, ←hdisj],
  refine F.inter_sets _ _,
    { rw ←@preimage_id _ U,
      exact tendsto_def.1 hFx U (mem_nhds_sets hU hxU) },
    { rw ←@preimage_id _ V,
      exact tendsto_def.1 hFy V (mem_nhds_sets hV hyV) }
end

variables {Y : Type*} [topological_space Y]

@[reducible] def filter_image (f : X → Y) (F : filter X) : filter Y := 
  generate $ (λ s : set X, f '' s) '' F

-- We'll use mathlib's `generate` and `map` which are the same 
-- as the ones we've defined but there is more APIs to work with

/-- The neighbourhood filter of `x` converges to `x` -/
lemma nhds_tendsto (x : X) : tendsto id (nhds x) (nhds x) := 
λ U hU, by rwa map_id

lemma mem_filter_image_iff {f : X → Y} {F : filter X} (V) : 
  V ∈ map f F ↔ ∃ U ∈ F, f '' U ⊆ V :=
begin
  refine ⟨λ h, ⟨_, h, image_preimage_subset _ _⟩, λ h, _⟩,
    rcases h with ⟨U, hU₀, hU₁⟩,
    rw mem_map,
    apply F.sets_of_superset hU₀,
    intros u hu,
    rw mem_set_of_eq,
    apply hU₁, rw mem_image,
    exact ⟨u, hu, rfl⟩    
end

lemma nhds_subset_filter_of_tendsto {x : X} {F : filter X} 
  (hF : tendsto id F (nhds x)) : (nhds x : set (set X)) ⊆ F :=
begin
  intros s hs,
  have := tendsto_def.1 hF _ hs,
  rwa preimage_id at this
end

/-- A map between topological spaces `f : X → Y` is continuous at some `x : X` 
  if for all `F : filter X` that tends to `x`, `map F` tends to `f(x)` -/
theorem continuous_of_filter_tendsto {x : X} (f : X → Y)
  (hF : ∀ F : filter X, tendsto id F (nhds x) → 
    tendsto id (map f F) (nhds (f x))) : continuous_at f x :=
λ _ hU, tendsto_def.1 (hF _ $ nhds_tendsto x) _ hU

/-- If `f : X → Y` is a continuous map between topological spaces, then for all 
  `F : filter X` that tends to `x`, `map F` tends to `f(x)` -/
theorem filter_tendsto_of_continuous {x : X} {F : filter X} (f : X → Y) 
  (hf : continuous_at f x) (hF : tendsto id F (nhds x)) : 
  tendsto id (map f F) (nhds (f x)) := 
begin
  rw tendsto_def at *, intros U hU,
  refine nhds_subset_filter_of_tendsto hF (hf hU),
end

end filter